# 腾讯笔试备考
* 64位操作系统
char ：1个字节(固定)
\*(即指针变量): 8个字节
short int : 2个字节(固定)
int： 4个字节(固定)
unsigned int : 4个字节(固定)
float: 4个字节(固定)
double: 8个字节(固定)
long: 8个字节
unsigned long: 8个字节(变化*其实就是寻址控件的地址长度数值)
long long: 8个字节(固定)
* 空类求sizeof为1，加不加构造函数对sizeof没影响，但有了虚函数，则需要有一个指针指向虚函数表，32位下，指针sizeof为4
* count(\*)肯定是查全部的记录条数了
count(数字)，和count(*)效果一样，有几条记录就显示几
count(属性名)则查处的是属性名下面的非null数据的个数
count()则报错 错误码: 1064
* 因为,地址寄存器是32位。而系统是二进制的，1位地址可以寻找2个空间。2位可以寻找4个空间。比如用两个符号AB去代表门牌号，那么就可以有4个号，00 ，01，11，10.
所以，地址空间是n位，就能寻址2 的n次方空间。
2^32=4 X 2^10 X 2^10 X 2^10 bit=4Gb
(2^10bit = 1Kb,2^10Kb = 1Mb,2^10Mb = 1Gb)
* unit16_t为2字节无符号整数，unit8_t位1字节无符号整数
* 由于栈的生长方向是从高地址向低地址，所以题目中的m是高地址，n是低地址。
而大端序是指权重高的数存放在低地址中，小端序相反（小端序才是符合阅读习惯的），
0x1234中，0x12 是高位，0x34是低位；按照大端序高位存放在低地址，即0x12存放在n中；
小端序相反
* 第一范式就是无重复的列。
第二范式就是非主属性非部分依赖于主关键字。
第三范式就是属性不依赖于其它非主属性。
第五范式（5NF）是最终范式，消除了4NF中的连接依赖
* TCP支持的应用协议主要有：Telnet、FTP、SMTP等；UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等
* android常用的跨**进程**通信工具有:
1.访问其他应用程序的Activity
2.Content Provider 
3.广播（Broadcast） 
4.AIDL服务
跨线程则主要有：handler
* 在C++中，析构函数的作用是：当一个对象被销毁时，调用析构函数对类对象和对象成员进行释放内存资源。
* 当我们定义一个指向派生类类型对象指针时，构造函数按照从基类到派生类的顺序被调用，但是当删除指向派生类的基类指针时，派生类的析构函数没有被调用，只是调用了基类的析构函数，此时派生类将会导致内存泄漏
* 我们需要将基类的析构函数声明为虚函数，此时在调用析构函数的时候是根据ptr指向的具体类型来调用析构函数，此时会调用派生类的析构函数。
* ios常用的多线程编程组件有：
1.GCD
2.NSOperationQueue
3.NSThread
* ping 使用的协议为icmp，通过域名解析，需要用到DNS，局域网中使用arp进行主机间的通信。TCP层是位于IP层之上,应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接
* 题干是表的Fuin、Fstate、Fcreate、ime建立复合索引，所以只用看选项的where子句。复合索引的列的顺序对查询是有很大影响的，例如建立索引：(姓, 名)，在索引文件中，它会先按照姓排序，在姓相同时，再按照名排序，而单独查询名或者先查询名是不会使用到索引的。
* p的地址为0，那么&p->i的地址为12，相当于i相对于结构体头地址的偏移量为12个字节，(char*)&a +q自然就指向的a中i的地址，i被修改为-50
* \#pragma pack(n)表示默认以n字节对齐，若某变量（如int）的字节大于n,则以n的倍数对齐。
* Mul(a+b,b+c)经过宏替换变成++a+b\*(++b)+c，即2+3*3+3 
优先级（）>  ++ > * > +
* 高峰阶段，抢红包的并发请求数可能达到8000次/秒，使用什么样的存储系统可以支持该方案?分布式、负载均衡、锁机制。
* Linux进程通信六大方式：
1，管道及(pipe)有名管道
2，信号（signal）                
3,  报文队列
4，共享内存
5，信号量(semaphore)
6，套接字（socket）
* DNS:域名到IP地址 ARP:IP地址到物理地址
* 有序分配锁资源可以预防死锁
* 剥夺死锁进程的所有资源可以解除死锁
* 银行家算法是用于避免死锁的
* 具有泛型类型参数的类型称之为：开放类型（open type），CLR禁止构造开发类型的任何实例。这一点类似于CLR禁止构造结构类型的实例。 代码引用一个泛型类型时，可指定一组泛型类型实参，假如所有类型实参传递的都是实际数据类型，类型就称为封闭类型（closed type）。CLR允许构造封闭类型的实例
* 唯一性约束和主键约束的区别：
    （1）.唯一性约束允许在该列上存在NULL值，而主键约束的限制更为严格，不但不允许有重复，而且也不允许有空值。
    （2）.在创建唯一性约束和主键约束时可以创建聚集索引和非聚集索引，但在 默认情况下主键约束产生聚集索引，而唯一性约束产生非聚集索引
* TCP发送的数据是有序的，接收端最后整成有序的，但接受的顺序不一定是有序的，会对其再次排序，从而保证结果的有序性。
* 度为2的结点n2,度为1的结点n1，度为0的结点n0
总度数为 n = 2\*n2+1*n1
总结点数 ~n =  n2+n1+n0
n = ~n - 1   ==> n0 = n2+1 = 11
* (1）const int\*p1：表示不能通过指针p1修改它指向的内存单元的值，但是p1本身可修改。
（2）int const\*p2=&i：与p1相同，即不能修改p2指向的内存单元的值，但是可以修改p2使其指向其它的内存单元。这里p2指向了整型变量i
（3）p2=&j：修改p2，使其指向整型变量 j ，由（2）可知（3）没错。
（4）int \*constp3=&i：p3本身是指向整型变量的常指针,即p3初始化后不能再指向其它的内存单元，但是可以修改p3指向的内存单元的值。这里p3指向了整型变量i。
（5）\*p3=20：通过p3将变量i的值修改为2，由(4)可知（5）没错。
（6）*p2=30：通过p2修改它所指向的内存单元的值，由（2）可知（6）错误。
（7）p3=&j：修改p3,使其指向j,由(4)可知（7）错误。
* &a表示一个指向大小为5数组的指针，那么&a+1就是表示一个指向大小为5的下一个数组的指针，也就是数组a最后一个元素的下一个位置，那么int*p=(int*)(&a+1)进行强制类型转换，将指向数组的指针转换为指向第二个数组中首元素的指针，所以p-1则是指向第一个数组中最后一个元素的指针，所以输出是5
* 设k1,k2是矩阵A的两个不同的特征值，a与b是A的分别属于k1,k2的特征向量，则由a与b是线性无关
* sizeof(testArray) 是数组大小 8*4  =32;
sizeof(testArray[0]) 是 testArray[0]的大小 4；
所以 sizeof(testArray)/sizeof(testArray[0]) = 8
* 10.1.8.0/24   前24位不变，表示的范围是10.1.8.0~10.1.8.255     10.1.9.0/24的范围表示 10.1.9.0~10.1.9.255，那么汇总应该是10.1.8.0/23，即前23位不变，因为8是1000，9是1001，所以减掉一位，也就是8+8+7=23
* 默认的拷贝构造函数是浅拷贝，直接把指针的值复制了一份。
调用sayHello，离开作用域，调用析构函数delete了一次。main函数中，又delete了一次。因此程序崩溃。
* HTTP是基于TCP协议之上的应用层协议
* HTTP协议的ETAG响应头主要用于信息的过期验证
* HTTP是文本协议，不是二进制协议
* cache-control是在HTTP1.1中才有的
* 线程和进程的区别联系：
1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。
2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 
两者都可以提高程序的并发度，提高程序运行效率和响应时间。 
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。
根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的： 
1、速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。 
2、资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。 
3、同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内
* C++中&有另外一个含义，用来声明引用，&不是地址运算符，而是类型标识符的一部分。就像声明char*指的是指向char的指针一样，int &指的是指向int的引用，变量和变量的引用指向相同的值和内存单元，引用相当于变量的别名。因此在参数传递时也只需要传递变量名即可，即Func(a)。它的形式上看起来与值传递相同，但它传递参数时不复制副本，与指针一样可以修改主调函数的参数值，且使用起来更方便。
* 正态分布曲线性质中有 ：P（μ-σ<X≤μ+σ）=68.3%P（μ-2σ<X≤μ+2σ）=95.4%P（μ-3σ<X≤μ+3σ）=99.7%；
* 最速下降法
* 在相同样本量下，重复抽样与不重复抽样的抽样平均误差大小关系是:重复抽样误差大
* SQL：count是对元组个数进行计数，sum是对属性数值进行求和
*  Z检验的条件：样本来自正态分布且方差已知的情况
T检验的条件：样本来自正态分布且方差未知的情况，两独立样本T检验主要用于检验两个样本的平均数差异。
U检验的条件：应用条件和t检验应用条件基本一致，  只是大样本时用u检验  ，小样本时用t检验，t检验可以代替U检验。（这一条同楼上）
* 拥塞窗口和接受窗口取最小值，所以目前客户端还能发送4kb，但是由于已经发送了第二个段，且第二段没超时，4-1=3
* 当定性变量含有m个类别时，模型不能引入m个虚拟变量。最多只能引入m-1个虚拟变量，否则当模型中存在截距项时就会产生完全多重共线性，无法估计回归参数。商品包装外观因素有4种颜色，所以这是一个含有4个类别的定性变量，应该向模型引入3个虚拟变量，如果引入4个，则无法估计回归参数
*  如果子类构造器没有显示地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中有没有显示地调用超类的其他构造器，则Java编译器将报告错误。使用super调用构造器的语句必须是子类构造器的第一条语句。
*  如果视图是从多个基本表使用联接操作导出的，则不允许更新。如果导出的视图使用了分组和聚合操作，也不允许更新。如果视图是从单个基本表使用选择和投影操作导出的，并且包括了基本表的主键或某个候选键，则可以执行操作。
*  ICMP协议用于控制数据报传送中的差错情况
*  RARP协议根据MAC地址查找对应的IP地址
*  NAT协议公网的IP地址转换为私网的IP地址
*  DHCP协议集中管理网络中的IP地址分配
*  首先要明白变量初始化的顺序是其声明的顺序,跟初始化列表中的顺序无关。所以变量的初始化顺序为m_nFir(i++)，m_nSec(i++)，m_nThd(i++)，&m_nFor(m_nThd);
i初始值为1，所以经过初始化列表初始化以后m_nFir=1，m_nSec=2，m_nThd=3，m_nFor为m_nThd的一个引用。
并且此时i的值为4，构造函数中执行语句m_nThd=i后，m_nThd=4,m_nFor是它的一个引用，自然值也为4。
输出结果m_nFir+m_nSec+m_nThd+m_nFor=1+2+4+4=11
* 网速为100Mbps，电影1G为1GByte，先应该变为相同的单位。
1*1024MByte/(100/8) =81.92s.
这是最大速度了，所以大于这个时间都是合理的。
* 当有一个TCP数据段不足MSS，比如要发送700Byte数据，MSS为1460Byte的情况。nagle算法会延迟这个数据段的发送，等待，直到有足够的数据填充成一个完整数据段。也许有人会问，这有什么影响呢？没有太大的影响，总体上来说，这种措施能节省不必要的资源消耗。但是要发送的总体数据很小时，这种措施就是拖后腿了。比如，用户请求一个网页，大约十几KB的数据，TCP先发送了八九个数据包，剩下几百字节一直不发送，要等到另一个RTT才发送，这时候前面发送数据的ACK已经返回了。这样的用户体验是很不好的。 所以，现在很多服务器都选择主动关闭nagle算法，因为带宽够大，资源消耗不是问题，速度反而是个大问题。
从上述描述中，禁用 nagle，实质就是不在延迟 TCP_NODELAY
* 首先得明确char类型占一个字节，int类型占4个字节，所以，sizeof（char）=1，sizeof（int）=4,
另外，ch是一个指针，只是指向了字符串"str"而已。所以sizeof（ch）不是 字符串 占的空间也不是字符 占的空间，而是一个字符型指针占的空间。所以sizeof(str1)=sizeof(char\*)=4，在 C/C++ 中一个指针占4个字节 
str是一个字符型数组。C/C++规定，对于一个数组，返回这个数组占的总空间，所以sizeof(str)取得的是字符串" Tencent "占的总空间。"Tencent"敏感词有T e n c e n t \0八个字符，所以str数组的长度是8，所以sizeof(str)=8*sizeof(char)=8
总之， 对于指针而言，sizeof 操作符返回这个指针占的空间，一般是4个字节；
而对于一个数组，sizeof返回这个数组所有元素占的总空间。
同时要知道strlen不区分是数组还是指针，就读到\0为止返回长度。并且strlen是不把\0计入字符串的长度的。
* 红黑树和avl树都属于自平衡二叉树；
两者查找、插入、删除的时间复杂度相同；
包含n个内部结点的红黑树的高度是o(logn);
TreeMap是一个红黑树的实现，能保证插入的值保证排序
* 16KB超时，阈值变为8KB，客户端从1KB开始穿（执行快开始算法）
1RTT 结束，1KB->2KB
2RTT 结束，2KB->4KB
3RTT 结束，4KB->8KB（到达阈值，执行拥塞避免算法）
4RTT 结束，8KB->9KB
* ip不用说了肯定是网络层协议，a对
icmp也不用说，icmp本质可以理解为带差错报告的ip协议，也是网络层，b对
arp是将ip地址解析为mac，rarp是arp的reverse，将mac解析为ip
所以虽然看上去他们工作都是在链路层，但是它们是网络层协议，cd也对
* 跳过FIN_WAIT_2,证明被动方也完成了数据传输任务，直接把ACK和FIN一起发给了主动方，因此主动方从FIN_WAIT_1直接跳过FIN_WAIT_2进入TIME_WAIT
* new和delete搭配，malloc和free搭配，所以A、B是错的。
关于D，注意new int(12)和new int[12]的区别。new int(12)是生成了一个值为12的int变量，new int[12]才是生成一个大小为12的数组。所以，delete []ip是错误的，D错。
再看C，乍一眼看过去，a是一个数组，应该用delete []a，但是在基本类型数组来说，delete a和delete []a的效果是一样的。如果，a是一个自定义对象的数组，那么只能用delete []a。
* A宏定义会单纯的替换，也就是如果宏定义替换的内容会成倍复制，所以会导致代码膨胀
B模板的调用，会根据调用的参数，生成模板对应的实际调用的函数体，如果调用的参数不同，会生成不同的代码，所以会导致代码膨胀
C内联函数会拷贝至调用的位置，如果调用多次回导致代码膨胀






